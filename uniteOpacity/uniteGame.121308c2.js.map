{"version":3,"sources":["map.ts","index.ts"],"names":[],"mappings":"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","file":"uniteGame.121308c2.js","sourceRoot":"..","sourcesContent":["\nexport interface FieldCell<CODE> { code: CODE, infectedByPlayer: boolean }\n\nexport const isInfectedByPlayer = <CODE>(fieldCell: FieldCell<CODE> | string) => {\n    if (typeof fieldCell === 'object') {\n        return fieldCell.infectedByPlayer;\n    }\n};\n\nconst autoplay = <CODE>(possibleCellCodes: CODE[], field: Array<Array<CODE | FieldCell<CODE>>>)  => {\n    // научится играть автоматически и считать количество необходимых ходов\n}\n\nconst getField = <CODE>(possibleCellCodes: CODE[]): Array<Array<CODE | FieldCell<CODE>>> => {\n    const debug = false;\n    if (debug) {\n        return [\n            [possibleCellCodes[0], possibleCellCodes[3], possibleCellCodes[0]],\n            [undefined, possibleCellCodes[3]],\n            [possibleCellCodes[0], { code: possibleCellCodes[2], infectedByPlayer: true }, possibleCellCodes[0]],\n        ];\n    }\n    const getRandomColor = () => {\n        return possibleCellCodes[Math.floor(Math.random() * possibleCellCodes.length)];\n    }\n    const columns = 13;\n    const rows = 13;\n\n    let generatedField = [];\n    for (let row = 0; row < rows; row++) {\n        generatedField[row] = [];\n        for (let column = 0; column < columns; column++) {\n            generatedField[row][column] = getRandomColor();\n        }\n    }\n    const randomRow = Math.floor(Math.random() * rows);\n    const randomColumn = Math.floor(Math.random() * columns);\n    const futureUserInfectedCell = generatedField[randomRow][randomColumn];\n    generatedField[randomRow][randomColumn] = { code: futureUserInfectedCell, infectedByPlayer: true };\n\n    return generatedField;\n}\n\nexport default getField;\n","import getField, { FieldCell, isInfectedByPlayer } from './map';\n\nenum COLOR {\n  BLUE = 'blue',\n  GREEN = 'green',\n  ORANGE = 'orange',\n  RED = 'red'\n}\n\nconst colors = [COLOR.BLUE, COLOR.GREEN, COLOR.ORANGE, COLOR.RED];\n\nconst field = getField<COLOR>(colors);\n\n\nclass Cell {\n  neighbors: Cell[];\n\n  master: string;\n  type: COLOR;\n\n  nodeEl: HTMLDivElement;\n\n  onInfectedCallback: () => void;\n\n  constructor(color: COLOR, onInfectedCallback: () => void) {\n    this.type = color;\n    this.master = 'self';\n    this.neighbors = [];\n\n    const node = document.getElementById('cellExample').cloneNode(true);\n    node.classList.add('visible', color);\n\n    this.nodeEl = node;\n    this.onInfectedCallback = onInfectedCallback;\n  }\n\n  notifyNeighbors(newType: COLOR, newMaster: string) {\n    this.neighbors.forEach(neighbor => {\n      neighbor.neighborCellUpdated(newType, newMaster);\n    })\n  }\n\n  neighborCellUpdated(newType: COLOR, newMaster: string) {\n    setTimeout(\n      () => {\n        if ((newType === this.type) || this.master === newMaster) {\n          this.update(newType, newMaster);\n        }\n      },\n      80\n    )\n  }\n\n  update(newType: COLOR, newMaster: string) {\n    let updated = false;\n    if (this.master !== newMaster) {\n      this.master = newMaster;\n      this.nodeEl.classList.add('infected');\n      this.onInfectedCallback();\n      updated = true;\n    }\n\n    if (this.type !== newType) {\n      this.nodeEl.classList.replace(this.type, newType);\n      this.nodeEl.classList.remove('infected');\n      setTimeout(() => {\n        this.nodeEl.classList.add('infected');\n      }, 100);\n      this.type = newType;\n      updated = true;\n    }\n\n    if (updated) {\n      this.notifyNeighbors(newType, newMaster);\n    }\n  }\n}\n\nlet rows = field.length;\nlet columns = 0;\n\n// ищем самую длинную строку и говорим, что это ширина сетки\nfield.forEach(row => {\n  if (row.length > columns) {\n    columns = row.length;\n  }\n});\n\nconst cellGrid: Array<Array<Cell>> = [];\nlet infectedCount = 0;\nlet cellOverall = 0;\nconst onInfected = () => {\n  infectedCount += 1;\n  document.getElementById('infectedCount').innerText = infectedCount + '';\n  const notInfectedCount = cellOverall - infectedCount;\n  document.getElementById('notInfectedCount').innerText = notInfectedCount + '';\n\n  if (notInfectedCount === 0) {\n    setTimeout(() => {\n      window.location.reload(false);\n    }, 200)\n  }\n}\n\nconst cellGridNode = document.getElementById('cellGrid');\ncellGridNode.style.gridTemplateColumns = `repeat(${columns}, auto)`;\ncellGridNode.style.gridTemplateRows = `repeat(${rows}, auto)`;\n\nlet infecedByPlayerCell;\n\nfor (let row = 0; row < rows; row++) {\n  cellGrid[row] = [];\n  for (let column = 0; column < columns; column++) {\n    const currentCell = field[row][column];\n    if (currentCell) {\n      const cellCode = typeof currentCell === 'string' ? currentCell : currentCell.code;\n      const cell = new Cell(cellCode, onInfected);\n      cellOverall += 1;\n      cellGrid[row][column] = cell;\n      cellGridNode.appendChild(cell.nodeEl);\n      if (isInfectedByPlayer(currentCell)) {\n        infecedByPlayerCell = cell;\n      }\n    } else {\n      cellGrid[row][column] = undefined;\n      cellGridNode.appendChild(document.createElement('div'));\n    }\n  }\n}\n\nfor (let row = 0; row < rows; row++) {\n  for (let column = 0; column < columns; column++) {\n    const cell = cellGrid[row][column];\n    if (cell) {\n      if (row !== 0) {\n        const topNeighbor = cellGrid[row - 1][column];\n        if (topNeighbor) {\n          cell.neighbors.push(topNeighbor);\n        }\n      }\n\n      if (row !== rows - 1) {\n        const bottomNeighbor = cellGrid[row + 1][column];\n        if (bottomNeighbor) {\n          cell.neighbors.push(bottomNeighbor);\n        }\n      }\n\n      if (column !== 0) {\n        const leftNeighbor = cellGrid[row][column - 1];\n        if (leftNeighbor) {\n          cell.neighbors.push(leftNeighbor);\n        }\n      }\n\n      if (column !== columns - 1) {\n        const rightNeighbor = cellGrid[row][column + 1];\n        if (rightNeighbor) {\n          cell.neighbors.push(rightNeighbor);\n        }\n      }\n    }\n  }\n}\n\nconst forceUpdatePlayerCell = (newType: COLOR) => {\n  infecedByPlayerCell.update(newType, 'player1');\n}\n\nforceUpdatePlayerCell(infecedByPlayerCell.type);\n\nconst setBlue = () => {\n  forceUpdatePlayerCell(COLOR.BLUE);\n}\nconst setGreen = () => {\n  forceUpdatePlayerCell(COLOR.GREEN);\n}\nconst setOrange = () => {\n  forceUpdatePlayerCell(COLOR.ORANGE);\n}\nconst setRed = () => {\n  forceUpdatePlayerCell(COLOR.RED);\n}\n\ndocument.querySelector('.colorButton button.blue').addEventListener('click', setBlue);\ndocument.querySelector('.colorButton button.green').addEventListener('click', setGreen);\ndocument.querySelector('.colorButton button.orange').addEventListener('click', setOrange);\ndocument.querySelector('.colorButton button.red').addEventListener('click', setRed);\n\ndocument.addEventListener('keydown', ({ code }) => {\n  switch (code) {\n    case 'KeyA': setBlue(); break;\n    case 'KeyS': setGreen(); break;\n    case 'KeyD': setOrange(); break;\n    case 'KeyF': setRed(); break;\n  }\n});\n"]}