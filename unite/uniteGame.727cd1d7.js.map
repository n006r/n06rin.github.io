{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","file":"uniteGame.727cd1d7.js","sourceRoot":"..","sourcesContent":["enum COLOR {\n  BLUE = 'blue',\n  GREEN = 'green',\n  ORANGE = 'orange',\n  RED = 'red'\n}\n\nconst colors = [COLOR.BLUE, COLOR.GREEN, COLOR.ORANGE, COLOR.RED];\nconst getRandomColor = () => {\n  return colors[Math.floor(Math.random() * colors.length)];\n}\n\n\nclass Cell {\n  topNeighbor?: Cell;\n  bottomNeighbor?: Cell;\n  leftNeighbor?: Cell;\n  rightNeighbor?: Cell;\n\n  code: COLOR;\n\n  nodeEl: HTMLDivElement;\n\n  onInfectedCallback: () => void;\n\n  constructor(color: COLOR, onInfectedCallback: () => void) {\n    this.code = color;\n\n    const node = document.createElement('div');\n    node.classList.add('cell', color);\n\n    // node.style.backgroundColor = color;\n    this.nodeEl = node;\n    this.onInfectedCallback = onInfectedCallback;\n  }\n\n  setInfected() {\n    if (!this.isInfected()) {\n      this.nodeEl.classList.add('infected');\n      this.onInfectedCallback();\n    }\n  }\n\n  isInfected() {\n    return this.nodeEl.classList.contains('infected');\n  }\n\n  neighborCellCodeUpdated(prevCode: COLOR, newCode: COLOR) {\n    if (prevCode === this.code && newCode !== this.code) {\n      this.updateCode(newCode);\n    }\n\n    if (newCode === this.code && !this.isInfected()) {\n      this.setInfected();\n      this.notifyNeighbors(this.code, this.code);\n    }\n  }\n\n  notifyNeighbors(oldCode: COLOR, newCode: COLOR) {\n    if (this.topNeighbor) {\n      this.topNeighbor.neighborCellCodeUpdated(oldCode, newCode);\n    }\n    if (this.rightNeighbor) {\n      this.rightNeighbor.neighborCellCodeUpdated(oldCode, newCode);\n    }\n    if (this.bottomNeighbor) {\n      this.bottomNeighbor.neighborCellCodeUpdated(oldCode, newCode);\n    }\n    if (this.leftNeighbor) {\n      this.leftNeighbor.neighborCellCodeUpdated(oldCode, newCode);\n    }\n  }\n\n  updateCode(newCode: COLOR) {\n    this.nodeEl.classList.replace(this.code, newCode);\n    const oldCode = this.code;\n    this.code = newCode;\n    this.notifyNeighbors(oldCode, newCode);\n  }\n\n  forceUpdateCode(newCode: COLOR) {\n    this.setInfected();\n    this.updateCode(newCode);\n  }\n}\n\nconst cellGrid: Array<Cell> = [];\n\nconst columns = 13;\nconst rows = 13;\n\nconst cellMap = [];\nfor (let row = 0; row < rows; row++) {\n  cellMap[row] = [];\n  for (let column = 0; column < columns; column++) {\n    cellMap[row][column] = getRandomColor();\n  }\n}\n\nlet infectedCount = 0;\nconst onInfected = () => {\n  infectedCount += 1;\n  document.getElementById('infectedCount').innerText = infectedCount + '';\n  const notInfectedCount = cellGrid.length - infectedCount;\n  document.getElementById('notInfectedCount').innerText = notInfectedCount + '';\n\n  if (notInfectedCount === 0) {\n    window.location.reload(false);\n  }\n}\n\nconst cellGridNode = document.getElementById('cellGrid');\ncellGridNode.style.gridTemplateColumns = `repeat(${columns}, auto)`;\ncellGridNode.style.gridTemplateRows = `repeat(${rows}, auto)`;\n\nfor (let row = 0; row < cellMap.length; row++) {\n  for (let column = 0; column < cellMap[row].length; column++) {\n    const cell = new Cell(cellMap[row][column], onInfected);\n    cellGrid.push(cell);\n    cellGridNode.appendChild(cell.nodeEl);\n  }\n}\n\nfor (let row = 0; row < rows; row++) {\n  for (let column = 0; column < columns; column++) {\n    const cell = cellGrid[row * columns + column];\n\n    cell.topNeighbor = (() => {\n      if (row === 0) {\n        return undefined;\n      }\n      return cellGrid[(row - 1) * columns + column];\n    })();\n\n    cell.bottomNeighbor = (() => {\n      if (row === rows - 1) {\n        return undefined;\n      }\n      return cellGrid[(row + 1) * columns + column];\n    })();\n\n    cell.leftNeighbor = (() => {\n      if (column === 0) {\n        return undefined;\n      }\n      return cellGrid[row * columns + column - 1];\n    })()\n\n    cell.rightNeighbor = (() => {\n      if (column === columns - 1) {\n        return undefined;\n      }\n\n      return cellGrid[row * columns + column + 1];\n    })()\n  }\n}\n\nconst centerCell = cellGrid[Math.floor(rows * columns / 2)];\n// const centerCell = cellGrid[cellGrid.length - 1];\ncenterCell.forceUpdateCode(centerCell.code);\ncenterCell.setInfected();\n\nconst setBlue = () => {\n  centerCell.forceUpdateCode(COLOR.BLUE);\n}\nconst setGreen = () => {\n  centerCell.forceUpdateCode(COLOR.GREEN);\n}\nconst setOrange = () => {\n  centerCell.forceUpdateCode(COLOR.ORANGE);\n}\nconst setRed = () => {\n  centerCell.forceUpdateCode(COLOR.RED);\n}\n\ndocument.querySelector('.colorButton button.blue').addEventListener('click', setBlue);\ndocument.querySelector('.colorButton button.green').addEventListener('click', setGreen);\ndocument.querySelector('.colorButton button.orange').addEventListener('click', setOrange);\ndocument.querySelector('.colorButton button.red').addEventListener('click', setRed);\n\ndocument.addEventListener('keydown', ({ code }) => {\n  switch (code) {\n    case 'KeyA': setBlue(); break;\n    case 'KeyS': setGreen(); break;\n    case 'KeyD': setOrange(); break;\n    case 'KeyF': setRed(); break;\n  }\n});\n"]}